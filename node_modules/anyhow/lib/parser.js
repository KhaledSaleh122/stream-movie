"use strict";
// Anyhow: Parser
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const utils_1 = require("./utils");
const preprocessors_1 = __importDefault(require("./preprocessors"));
const util_1 = __importDefault(require("util"));
/**
 * Parser methods to build a message out of passed logging arguments.
 */
class AnyhowParser {
    static _instance;
    /** @hidden */
    static get Instance() {
        return this._instance || (this._instance = new this());
    }
    /**
     * Library options (internal).
     */
    _options;
    /**
     * Get library options.
     */
    get options() {
        return this._options;
    }
    /**
     * Set library options.
     */
    set options(value) {
        this._options = value;
        if (value.preprocessors && (0, utils_1.isArray)(value.preprocessors)) {
            this.builtinPreProcessors = value.preprocessors.filter((pp) => (0, utils_1.isString)(pp));
            this.customPreProcessors = value.preprocessors.filter((pp) => (0, utils_1.isFunction)(pp));
        }
        else {
            this.builtinPreProcessors = [];
            this.customPreProcessors = [];
        }
        this._isDebug = this.options.levels.includes("debug");
    }
    /**
     * Is the "debug" level active?
     */
    _isDebug;
    /**
     * Is the "debug" level active?
     */
    get isDebug() {
        return this._isDebug;
    }
    /**
     * List of active built-in preprocessors.
     */
    builtinPreProcessors = [];
    /**
     * List of active custom preprocessors.
     */
    customPreProcessors = [];
    // METHODS
    // --------------------------------------------------------------------------
    /**
     * Used by [[getMessage]] to parse and return the individual log strings
     * out of the passed arguments. Might run recursively.
     * @param args Array of arguments to be parsed.
     */
    argumentsParser = (args) => {
        let result = [];
        // Parse all arguments and stringify objects. Please note that fields defined
        // on the `removeFields` setting won't be added to the message.
        for (let arg of args) {
            try {
                if (arg != null) {
                    let stringified = "";
                    try {
                        if ((0, utils_1.isObject)(arg)) {
                            stringified = JSON.stringify(arg, null, 2);
                        }
                        else {
                            stringified = arg.toString();
                        }
                    }
                    catch (ex) {
                        /* istanbul ignore next */
                        stringified = arg.toString();
                    }
                    // Compact the output message?
                    if (stringified && this.options.compact) {
                        stringified = stringified.replace(/(\r\n|\n|\r)/gm, "").replace(/  +/g, " ");
                    }
                    result.push(stringified);
                }
            }
            catch (ex) {
                /* istanbul ignore next */
                if (this.isDebug) {
                    console.error("Anyhow.argumentsParser: failed to parse arguments");
                    console.error(ex);
                }
            }
        }
        return result;
    };
    /**
     * Gets a nice, readable message out of the passed arguments, which can be of any type.
     * @param args Objects or variables that should be stringified.
     * @param ignoredPreProcessors List of ignored preprocessors.
     * @returns Human readable string taken out of the parsed arguments.
     */
    getMessage = (args, ignoredPreProcessors) => {
        let strMessage = null;
        if ((0, utils_1.isNil)(args)) {
            strMessage = "";
        }
        else {
            if (!(0, utils_1.isArray)(args)) {
                args = [args];
            }
            if (args.length == 1 && (0, utils_1.isString)(args[0])) {
                strMessage = args[0];
            }
        }
        if (strMessage !== null) {
            return strMessage;
        }
        try {
            const builtinPreProcessors = this.builtinPreProcessors.filter((pp) => (ignoredPreProcessors ? ignoredPreProcessors.includes(pp) : true));
            const customPreProcessors = this.customPreProcessors;
            // Flatten the array if the compact option is set.
            if (this.options.compact) {
                args = (0, utils_1.flattenArray)(args);
            }
            // Execute built-in preprocessors (if any).
            if (this.builtinPreProcessors.length > 0) {
                args = preprocessors_1.default.run(this.options, args, builtinPreProcessors);
            }
            // Execute custom preprocessors (if any).
            for (let pp of customPreProcessors) {
                try {
                    args = pp(args) || args;
                }
                catch (ex) {
                    if (this.isDebug) {
                        console.error("Anyhow: failed to execute custom preprocessor");
                        console.error(ex);
                    }
                }
            }
            // Return single string log message.
            const messages = this.argumentsParser(args);
            return messages.join(this.options.separator);
        }
        catch (ex) {
            /* istanbul ignore next */
            if (this.isDebug) {
                console.error("Anyhow.getMessage: failed to generate message");
                console.error(ex);
            }
        }
    };
    /**
     * Gets a nice, readable JSON representation of the passed arguments.
     * @param args Objects or variables that should be stringified.
     */
    getInspection = (args) => {
        const result = [];
        const options = {
            compact: false,
            colors: true,
            depth: this.options.maxDepth,
            showHidden: false
        };
        // Iterate and process the passed arguments.
        for (let obj of args) {
            let objType;
            if (obj) {
                if (obj.constructor && obj.constructor.name) {
                    objType = obj.constructor.name;
                }
                else {
                    objType = Object.prototype.toString.call(obj).match(/^\[object\s(.*)\]$/)[1];
                }
                result.push(`${objType}\n${"-".repeat(objType.length)}`);
            }
            result.push(util_1.default.inspect(obj, options));
        }
        return result.join("\n");
    };
}
module.exports = AnyhowParser.Instance;
