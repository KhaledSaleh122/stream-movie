"use strict";
// Anyhow: preprocessors
const utils_1 = require("./utils");
/**
 * Parser methods to build a message out of passed logging arguments.
 */
class AnyhowPreProcessors {
    static _instance;
    /** @hidden */
    static get Instance() {
        return this._instance || (this._instance = new this());
    }
    // MAIN METHOD
    // --------------------------------------------------------------------------
    /**
     * Execute the passed preprocessors.
     * @param options Library options.
     * @param args Arguments to be processed.
     * @param preprocessors List of preprocessors to be executed.
     */
    run = (options, args, preprocessors) => {
        const hasFriendlyErrors = preprocessors.includes("friendlyErrors");
        const hasCleanup = preprocessors.includes("cleanup");
        const hasMaskSecrets = preprocessors.includes("maskSecrets");
        if (hasFriendlyErrors) {
            this.friendlyErrors(options, args);
        }
        // Stringify and clone objects?
        if (options.preprocessorOptions && options.preprocessorOptions.clone) {
            args = (0, utils_1.cloneDeep)(args, options.levels.includes("debug"), options.maxDepth);
        }
        if (hasCleanup) {
            this.cleanupArray(options, args, 0);
        }
        if (hasMaskSecrets) {
            this.maskSecretsArray(options, args, 0);
        }
        return args;
    };
    // CLEANUP
    // --------------------------------------------------------------------------
    /**
     * Cleanup logged parameters (arrays).
     * @param options Library options.
     * @param args Array to be processed.
     * @param depth Current depth on the array tree.
     */
    cleanupArray = (options, args, depth) => {
        for (let i = 0; i < args.length; i++) {
            const obj = args[i];
            /* istanbul ignore next */
            if (!obj)
                continue;
            if ((0, utils_1.isArray)(obj)) {
                if (depth == options.maxDepth) {
                    args[i] = "[...]";
                }
                else {
                    this.cleanupArray(options, obj, depth + 1);
                }
            }
            else if ((0, utils_1.isFunction)(obj)) {
                args[i] = "[Function]";
            }
            else if ((0, utils_1.isObject)(obj)) {
                if (Object.keys(obj).length == 0) {
                    args[i] = (0, utils_1.getTag)(obj);
                }
                else {
                    this.cleanupObject(options, obj, depth + 1);
                }
            }
        }
    };
    /**
     * Cleanup logged parameters (objects).
     * @param options Library options.
     * @param obj Object to be processed.
     * @param depth Current depth on the objects tree.
     */
    cleanupObject = (options, obj, depth) => {
        let entries = Object.entries(obj);
        let key;
        let value;
        for ([key, value] of entries) {
            if ((0, utils_1.isArray)(value)) {
                this.cleanupArray(options, value, depth + 1);
            }
            else if ((0, utils_1.isFunction)(obj)) {
                obj[key] = "[Function]";
            }
            else if ((0, utils_1.isObject)(value)) {
                if (depth == options.maxDepth) {
                    obj[key] = "[...]";
                }
                else if (Object.keys(value).length == 0) {
                    obj[key] = (0, utils_1.getTag)(value);
                }
                else {
                    this.cleanupObject(options, value, depth + 1);
                }
            }
            else if ((0, utils_1.isDate)(value)) {
                obj[key] = value.toLocaleString();
            }
        }
    };
    // FRIENDLY ERRORS
    // --------------------------------------------------------------------------
    /**
     * Extract relevant details from known exceptions.
     * @param options Library options.
     * @param args Arguments to be processed.
     */
    friendlyErrors = (options, args) => {
        for (let i = 0; i < args.length; i++) {
            const obj = args[i];
            /* istanbul ignore next */
            if (!obj || (0, utils_1.isString)(obj))
                continue;
            let arrError = [];
            let code;
            let friendlyMessage;
            let message;
            // Typed error?
            if ((0, utils_1.isError)(obj)) {
                code = obj.statusCode || obj.code;
                friendlyMessage = obj.friendlyMessage || obj.reason;
                message = obj.message || obj.description;
                // Add error information separately.
                if (code)
                    arrError.push(`Code ${code}`);
                if (friendlyMessage)
                    arrError.push(friendlyMessage);
                if (message)
                    arrError.push(message);
            }
            // Try extracting error details from axios / request exceptions.
            if (obj.response && obj.response.data) {
                try {
                    let dataMessage;
                    let dataError;
                    if (!code && obj.response.statusCode) {
                        arrError.push(`Code ${obj.response.statusCode}`);
                    }
                    if (obj.response.data.message) {
                        dataMessage = obj.response.data.message.toString();
                        if (dataMessage != "[object Object]" && dataMessage != message) {
                            arrError.push(dataMessage);
                        }
                    }
                    if (obj.response.data.error) {
                        dataError = (obj.response.data.error.message || obj.response.data.error).toString();
                        if (dataError != "[object Object]" && dataError != dataMessage && dataError != message) {
                            arrError.push(dataError);
                        }
                    }
                }
                catch (axiosEx) { }
            }
            if (arrError.length > 0) {
                if (options.preprocessorOptions && options.preprocessorOptions.errorStack && obj.stack) {
                    arrError.push(obj.stack.toString());
                }
                args[i] = arrError.join(options.separator);
            }
        }
    };
    // MASK SECRETS
    // --------------------------------------------------------------------------
    /**
     * Mask secrets (arrays).
     * @param options Library options.
     * @param args Array to be processed.
     * @param depth Current depth on the array tree.
     */
    maskSecretsArray = (options, args, depth) => {
        for (let i = 0; i < args.length; i++) {
            const obj = args[i];
            /* istanbul ignore next */
            if (!obj)
                continue;
            if ((0, utils_1.isArray)(obj))
                this.maskSecretsArray(options, obj, depth + 1);
            else if ((0, utils_1.isObject)(obj))
                this.maskSecretsObject(options, obj, depth + 1);
        }
    };
    /**
     * Mask secrets (objects).
     * @param options Library options.
     * @param obj Object to be processed.
     * @param depth Current depth on the objects tree.
     */
    maskSecretsObject = (options, obj, depth) => {
        const entries = Object.entries(obj);
        let key;
        let value;
        for ([key, value] of entries) {
            if ((0, utils_1.isArray)(value)) {
                this.maskSecretsArray(options, value, depth + 1);
            }
            else if ((0, utils_1.isObject)(value)) {
                this.maskSecretsObject(options, value, depth + 1);
            }
            else if (options.preprocessorOptions.maskedFields.includes(key)) {
                obj[key] = "[***]";
            }
        }
    };
}
module.exports = AnyhowPreProcessors.Instance;
