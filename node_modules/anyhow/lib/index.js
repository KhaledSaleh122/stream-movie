"use strict";
// Anyhow: index.ts
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const setup_1 = require("./setup");
const utils_1 = require("./utils");
const parser_1 = __importDefault(require("./parser"));
// Chalk (colorized console output). Will be instantiated on setup().
let chalk = null;
// Default options.
const defaultOptions = {
    compact: true,
    maxDepth: 5,
    appName: "Anyhow",
    separator: " | ",
    levels: ["info", "warn", "error"],
    styles: {
        debug: ["gray"],
        info: ["white"],
        warn: ["yellow"],
        error: ["red", "bold"]
    },
    preprocessors: [],
    preprocessorOptions: {
        maskedFields: ["password", "passcode", "secret", "token", "accessToken", "access_token", "refreshToken", "refresh_token", "clientSecret", "client_secret", "Authorization"],
        clone: true
    }
};
/**
 * This is the main class of the Anyhow library.
 * @example const logger = require("anyhow")
 */
class Anyhow {
    static _instance;
    /** @hidden */
    static get Instance() {
        return this._instance || (this._instance = new this());
    }
    /**
     * Init with default options.
     */
    constructor() {
        this.options = (0, utils_1.cloneDeep)(defaultOptions);
    }
    // PROPERTIES
    // --------------------------------------------------------------------------
    /**
     * Internal object defining a Logger.
     */
    _logger = null;
    /**
     * Getter for _lib, to be used by external modules.
     */
    get logger() {
        return this._logger;
    }
    /**
     * For compatibility only, now returns the logger's name.
     */
    get lib() {
        return this._logger ? this._logger.name : "none";
    }
    /**
     * Helper to check if [[setup]] was already called and logger is ready to log.
     */
    get isReady() {
        if (this._logger) {
            return true;
        }
        return false;
    }
    /**
     * Library options (internal).
     */
    _options;
    /**
     * Get library options.
     */
    get options() {
        return this._options;
    }
    /**
     * Set library options.
     */
    set options(value) {
        const newOptions = value ? (0, utils_1.mergeDeep)(defaultOptions, value) : (0, utils_1.cloneDeep)(defaultOptions);
        this.applyOptions(newOptions);
    }
    /**
     * Function to catch and log uncaught exceptions, set by [[uncaughtExceptions]].
     */
    _uncaughtExceptionHandler = null;
    /**
     * Enable or disable the uncaught exception handler.
     */
    set uncaughtExceptions(value) {
        if (value) {
            this._uncaughtExceptionHandler = (err) => {
                this.error(this._options.appName, "Uncaught exception", err);
                return;
            };
            process.on("uncaughtException", this._uncaughtExceptionHandler);
        }
        else {
            if (this._uncaughtExceptionHandler) {
                process.off("uncaughtException", this._uncaughtExceptionHandler);
            }
            this._uncaughtExceptionHandler = null;
        }
    }
    /**
     * Function to catch and log unhandled rejections, set by [[unhandledRejections]].
     */
    _unhandledRejectionHandler = null;
    /**
     * Enable or disable the unhandled rejection handler.
     */
    set unhandledRejections(value) {
        if (value) {
            this._unhandledRejectionHandler = (err) => {
                this.error(this._options.appName, "Unhandled rejection", err);
                return;
            };
            process.on("unhandledRejection", this._unhandledRejectionHandler);
        }
        else {
            if (this._unhandledRejectionHandler) {
                process.off("Unhandled rejection", this._unhandledRejectionHandler);
            }
            this._unhandledRejectionHandler = null;
        }
    }
    /**
     * Auto-generated list of messages that should not be logged.
     */
    ignoreMessages = {};
    // LEGACY PROPERTIES
    // --------------------------------------------------------------------------
    /**
     * Please use options.appName.
     * @deprecated
     */
    /* istanbul ignore next */
    set appName(value) {
        this.deprecated("appName", `Please use setOptions({appName: "${value}"})`);
        this.setOptions({ appName: value });
    }
    /**
     * Please use options.compact.
     * @deprecated
     */
    /* istanbul ignore next */
    set compact(value) {
        this.deprecated("compact", `Please use setOptions({compact: ${value}})`);
        this.setOptions({ compact: value });
    }
    /**
     * Please use options.preprocessorOptions.errorStack.
     * @deprecated
     */
    /* istanbul ignore next */
    set errorStack(value) {
        this.deprecated("errorStack", `Please use setOptions({preprocessorOptions: {errorStack: ${value}}})`);
    }
    /**
     * Please use options.levels.
     * @deprecated
     */
    /* istanbul ignore next */
    set levels(value) {
        this.deprecated("levels", `Please use setOptions({levels: []})`);
        this.setOptions({ levels: value });
    }
    /**
     * Please use options.separator.
     * @deprecated
     */
    /* istanbul ignore next */
    set separator(value) {
        this.deprecated("separator", `Please use setOptions({separator: "${value}"})`);
        this.setOptions({ separator: value });
    }
    /**
     * Please use options.timestamp.
     * @deprecated
     */
    /* istanbul ignore next */
    set timestamp(value) {
        this.deprecated("timestamp", `Please use setOptions({timestamp: ${value}})`);
        this.setOptions({ timestamp: value });
    }
    /**
     * Please use options.preprocessors.
     * @deprecated
     */
    /* istanbul ignore next */
    set preprocessor(value) {
        this.deprecated("preprocessor", `Please use setOptions({preprocessors: [id_or_function]})`);
        this.setOptions({ preprocessors: [value] });
    }
    /**
     * Please use options.styles.
     * @deprecated
     */
    /* istanbul ignore next */
    set styles(value) {
        this.deprecated("styles", `Please use setOptions({styles: {}})`);
        this.setOptions({ styles: value });
    }
    // LOGGING METHODS
    // --------------------------------------------------------------------------
    /**
     * Default logging method.
     * @param level String representing the level: error, warn, info, verbose, debug, silly
     * @param args Array of arguments to be logged.
     * @returns The generated message that was just logged.
     */
    log(level, args) {
        if (this._options.levels.indexOf(level) < 0)
            return null;
        let message = parser_1.default.getMessage(args);
        // Add timestamp?
        if (this.options.timestamp) {
            message = `${(0, utils_1.getTimestamp)()}${this.options.separator}${message}`;
        }
        // If setup was not called yet, defaults to console logging and emit warning.
        if (!this.isReady) {
            console.warn("Anyhow: please call Anyhow's setup() on your application startup. Will default to console.log() for now.");
            this.setup("console");
            this.console(level, message);
        }
        else {
            this._logger.log(level, message);
        }
        return message;
    }
    /**
     * Shortcut to [[log]]("debug", args).
     */
    debug = (...args) => {
        if (this._options.levels.indexOf("debug") < 0)
            return null;
        if (args.length < 1)
            return;
        let message = parser_1.default.getMessage(args, ["friendlyErrors"]);
        return this.log("debug", message);
    };
    /**
     * Shortcut to [[log]]("info", args).
     */
    info = (...args) => {
        if (this._options.levels.indexOf("info") < 0)
            return null;
        if (args.length < 1)
            return;
        let message = parser_1.default.getMessage(args, ["friendlyErrors"]);
        return this.log("info", message);
    };
    /**
     * Shortcut to [[log]]("warn", args).
     */
    warn = (...args) => {
        if (this._options.levels.indexOf("warn") < 0)
            return null;
        if (args.length < 1)
            return;
        let message = parser_1.default.getMessage(args);
        return this.log("warn", message);
    };
    /**
     * Shortcut to [[log]]("error", args).
     */
    error = (...args) => {
        if (this._options.levels.indexOf("error") < 0)
            return null;
        if (args.length < 1)
            return;
        let message = parser_1.default.getMessage(args);
        return this.log("error", message);
    };
    /**
     * Shortcut to [[log]]("warn", args), with a deprecation notice.
     * Will not log if the noDeprecation flag is set.
     */
    deprecated = (...args) => {
        if (args.length < 1 || process["noDeprecation"])
            return;
        let message = parser_1.default.getMessage(args);
        if (this.ignoreMessages[message]) {
            this.ignoreMessages[message]++;
            return "";
        }
        this.ignoreMessages[message] = 1;
        return this.log("warn", `DEPRECATED! ${message}`);
    };
    /**
     * Shortcut to [[log]]("debug", args) with object inspection instead of plain text.
     */
    inspect = (...args) => {
        if (args.length < 1)
            return;
        let message = parser_1.default.getInspection(args);
        return this.log("debug", message);
    };
    /**
     * Log directly to the console. This is the default logger handler
     * in case no other compatible libraries are found.
     * @param level String representing the level: error, warn, info, debug
     * @param args Array of arguments to be logged.
     * @returns The generated message that was just logged.
     */
    console = (level, args) => {
        if (this._options.levels.indexOf(level.toLowerCase()) < 0)
            return null;
        let message = parser_1.default.getMessage(args);
        // Add level to the output?
        if (this._options.levelOnConsole) {
            message = `${level.toUpperCase()}: ${message}`;
        }
        let styledMessage = message;
        let logMethod = console.log;
        // Check if console supports the passed level. Defaults to "log".
        if (console[level] && level != "debug") {
            logMethod = console[level];
        }
        // Is chalk enabled? Use it to colorize the messages.
        if (chalk && this._options.styles) {
            let styles = this._options.styles[level];
            let chalkStyle;
            if (styles) {
                chalkStyle = chalk;
                for (let s of styles) {
                    chalkStyle = chalkStyle[s];
                }
            }
            else {
                chalkStyle = chalk.white;
            }
            styledMessage = chalkStyle(message);
        }
        logMethod(styledMessage);
        return message;
    };
    // SETUP AND CONFIGURING
    // --------------------------------------------------------------------------
    /**
     * Setup will try to load compatible loggers, and fall back to the console
     * if nothing was found. Will try using libraries on this order:
     * winston, bunyan, pino, gcloud, console.
     * @param lib Optional, force a specific library or Logger to be used, defaults to console.
     * @param libOptions Additional options to be passed to the underlying logging library.
     */
    setup = (lib, libOptions) => {
        if (!lib)
            lib = "console";
        (0, setup_1.libSetup)(this, lib, libOptions);
        if (lib == "console" && this._options.styles) {
            try {
                if (chalk === null) {
                    chalk = require("chalk");
                }
            }
            catch (ex) {
                /* istanbul ignore next */
                chalk = false;
            }
        }
    };
    /**
     * Helper to set partial library options. Only the passed parameters will be updated.
     * @param options Options to be updated.
     */
    setOptions = (options) => {
        if (!options)
            return;
        const newOptions = (0, utils_1.mergeDeep)(this._options, options);
        this.applyOptions(newOptions);
    };
    /**
     * Apply a new options object to the library.
     * @param newOptions New options object to be applied.
     */
    applyOptions = (newOptions) => {
        if (newOptions.levels && newOptions.levels.length > 0) {
            newOptions.levels = (0, utils_1.dedupArray)(newOptions.levels);
        }
        else {
            newOptions.levels = [];
        }
        if (newOptions.preprocessors && newOptions.preprocessors.length > 0) {
            newOptions.preprocessors = (0, utils_1.dedupArray)(newOptions.preprocessors);
        }
        else {
            newOptions.preprocessors = [];
        }
        if (newOptions.preprocessorOptions && newOptions.preprocessorOptions.maskedFields && newOptions.preprocessorOptions.maskedFields.length > 0) {
            newOptions.preprocessorOptions.maskedFields = (0, utils_1.dedupArray)(newOptions.preprocessorOptions.maskedFields);
        }
        if (newOptions.styles) {
            for (let key in newOptions.styles) {
                if (newOptions.styles[key].length > 0) {
                    newOptions.styles[key] = (0, utils_1.dedupArray)(newOptions.styles[key]);
                }
            }
        }
        else {
            newOptions.styles = {};
        }
        this.uncaughtExceptions = newOptions.uncaughtExceptions;
        this.unhandledRejections = newOptions.unhandledRejections;
        this._options = newOptions;
        parser_1.default.options = newOptions;
    };
}
module.exports = Anyhow.Instance;
