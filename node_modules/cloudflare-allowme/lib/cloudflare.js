"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cleanup = exports.ipBlock = exports.ipAllow = exports.createFirewall = exports.getFirewallId = exports.createList = exports.getListItems = exports.getListName = exports.getListId = exports.getZoneId = exports.getAccountId = void 0;
const utils_1 = require("./utils");
const logger = require("anyhow");
const settings = require("./settings");
const axios_1 = __importDefault(require("axios"));
const commentPrefix = "AllowMe: ";
const ipTimestamp = {};
const getAccountId = async () => {
    try {
        const res = await makeRequest("accounts");
        if (res.length > 0) {
            logger.info("Cloudflare.getAccountId", res[0].id);
            return res[0].id;
        }
        else {
            throw new Error("No accounts allowed for the current token");
        }
    }
    catch (ex) {
        logger.error("Cloudflare.getAccountId", ex);
    }
};
exports.getAccountId = getAccountId;
const getZoneId = async () => {
    try {
        const res = await makeRequest(`zones?name=${settings.cloudflare.zone}`);
        if (res.length > 0) {
            logger.info("Cloudflare.getZoneId", res[0].id);
            return res[0].id;
        }
        else {
            throw new Error(`Invalid zone: ${settings.cloudflare.zone}`);
        }
    }
    catch (ex) {
        logger.error("Cloudflare.getZoneId", ex);
    }
};
exports.getZoneId = getZoneId;
const getListId = async () => {
    try {
        const res = await makeRequest(`accounts/${settings.cloudflare.accountId}/rules/lists`);
        const list = res.find((i) => i.name == "allowme" && i.kind == "ip");
        if (list) {
            logger.info("Cloudflare.getListId", list.id);
            return list.id;
        }
        else if (res.length == 0) {
            const listId = await (0, exports.createList)();
            logger.info("Cloudflare.getListId", listId);
            return listId;
        }
        else {
            throw new Error(`No "allowme" IP list was found`);
        }
    }
    catch (ex) {
        logger.error("Cloudflare.getListId", ex);
    }
};
exports.getListId = getListId;
const getListName = async () => {
    try {
        const res = await makeRequest(`accounts/${settings.cloudflare.accountId}/rules/lists/${settings.cloudflare.listId}`);
        if (res) {
            logger.info("Cloudflare.getListName", res.name);
            return res.name;
        }
        else {
            throw new Error(`Invalid list ID: ${settings.cloudflare.listId}`);
        }
    }
    catch (ex) {
        logger.error("Cloudflare.getListName", ex);
    }
};
exports.getListName = getListName;
const getListItems = async () => {
    try {
        const res = await makeRequest(`accounts/${settings.cloudflare.accountId}/rules/lists/${settings.cloudflare.listId}/items`);
        if (res) {
            return res;
        }
        else {
            throw new Error(`No list IPs were returned`);
        }
    }
    catch (ex) {
        logger.error("Cloudflare.getListItems", ex);
    }
};
exports.getListItems = getListItems;
const createList = async () => {
    try {
        const data = { name: "allowme", kind: "ip", description: "Generated by AllowMe" };
        const res = await makeRequest(`accounts/${settings.cloudflare.accountId}/rules/lists`, "POST", data);
        logger.info("Cloudflare.createList", res.id);
        return res.id;
    }
    catch (ex) {
        logger.error("Cloudflare.createList", ex);
    }
};
exports.createList = createList;
const getFirewallId = async () => {
    try {
        const res = await makeRequest(`zones/${settings.cloudflare.zoneId}/firewall/rules`);
        const rule = res.find((i) => i.action == "allow" && i.filter.expression.includes("ip.src in $allowme"));
        if (rule) {
            logger.info("Cloudflare.getFirewallId", rule.id);
            return rule.id;
        }
        else {
            const ruleId = await (0, exports.createFirewall)();
            logger.info("Cloudflare.getFirewallId", ruleId);
            return ruleId;
        }
    }
    catch (ex) {
        logger.error("Cloudflare.getFirewallId", ex);
    }
};
exports.getFirewallId = getFirewallId;
const createFirewall = async () => {
    try {
        const filter = { expression: `ip.src in $${settings.cloudflare.listName}` };
        const data = [{ priority: 1, action: "allow", filter: filter, description: "Generated by AllowMe" }];
        const res = await makeRequest(`zones/${settings.cloudflare.zoneId}/firewall/rules`, "POST", data);
        const id = res[0].id;
        logger.info("Cloudflare.createFirewall", id);
        return id;
    }
    catch (ex) {
        logger.error("Cloudflare.createFirewall", ex);
    }
};
exports.createFirewall = createFirewall;
const ipAllow = async (ip, device) => {
    try {
        const validIP = (0, utils_1.parseIP)(ip);
        if (!validIP) {
            logger.warn("Cloudflare.ipBlock", ip, device, "Invalid IP");
            return false;
        }
        ipTimestamp[validIP] = new Date().valueOf();
        const items = await (0, exports.getListItems)();
        if (items.find((i) => i.ip == validIP)) {
            logger.info("Cloudflare.ipAllow", validIP, device, "IP already on the list");
            return false;
        }
        const data = [{ ip: validIP, comment: `${commentPrefix} ${device}` }];
        await makeRequest(`accounts/${settings.cloudflare.accountId}/rules/lists/${settings.cloudflare.listId}/items`, "POST", data);
        logger.info("Cloudflare.ipAllow", validIP, device);
        return true;
    }
    catch (ex) {
        logger.error("Cloudflare.ipAllow", ip, device, ex);
        throw ex;
    }
};
exports.ipAllow = ipAllow;
const ipBlock = async (ip, device) => {
    try {
        const validIP = (0, utils_1.parseIP)(ip);
        if (!validIP) {
            logger.warn("Cloudflare.ipBlock", ip, device, "Invalid IP");
            return false;
        }
        const items = await (0, exports.getListItems)();
        const ipItem = items.find((i) => i.ip == validIP);
        if (!ipItem) {
            logger.warn("Cloudflare.ipBlock", validIP, device, "IP not on the list");
            return false;
        }
        const data = { items: [{ id: validIP }] };
        await makeRequest(`accounts/${settings.cloudflare.accountId}/rules/lists/${settings.cloudflare.listId}/items`, "DELETE", data);
        logger.info("Cloudflare.ipBlock", validIP, device, `Removed ${ipItem.id}`);
        return true;
    }
    catch (ex) {
        logger.error("Cloudflare.ipBlock", ip, device, ex);
        throw ex;
    }
};
exports.ipBlock = ipBlock;
const cleanup = async () => {
    try {
        const now = new Date().valueOf();
        const age = parseInt(settings.ip.maxAge) * 1000 * 60;
        const data = { items: [] };
        const items = await (0, exports.getListItems)();
        for (let item of items) {
            if (item.comment && item.comment.substring(0, commentPrefix.length) == commentPrefix) {
                const created = new Date(item.created_on).valueOf();
                const timestamp = ipTimestamp[item.ip] || 0;
                if (now - age >= created && now - age >= timestamp) {
                    const device = item.comment.substring(commentPrefix.length + 1);
                    logger.info("Cloudflare.cleanup", item.ip, device, "Will be removed");
                    data.items.push({ id: item.id });
                }
            }
            else if (item.comment && item.comment.substring(0, 8).toLowerCase() == "expires:") {
                const expire = item.comment.split(":")[1].trim();
                const timestamp = new Date(expire).valueOf();
                if (now - age >= timestamp) {
                    logger.info("Cloudflare.cleanup", item.ip, item.comment, "Will be removed");
                    data.items.push({ id: item.id });
                }
            }
        }
        if (data.items.length > 0) {
            await makeRequest(`accounts/${settings.cloudflare.accountId}/rules/lists/${settings.cloudflare.listId}/items`, "DELETE", data);
            logger.info("Cloudflare.cleanup", `Removed ${data.items.length} IP(s)`);
        }
    }
    catch (ex) {
        logger.error("Cloudflare.cleanup", ex);
    }
};
exports.cleanup = cleanup;
const makeRequest = async (path, method, body) => {
    try {
        const options = {
            method: method || "GET",
            headers: { Authorization: `Bearer ${settings.cloudflare.token}` }
        };
        if (body) {
            options.data = body;
        }
        const res = await (0, axios_1.default)(`https://api.cloudflare.com/client/v4/${path}`, options);
        if (res.data && res.data.result) {
            return res.data.result;
        }
        else if (!body) {
            throw new Error(`Invalid data: ${path}`);
        }
    }
    catch (ex) {
        if (ex.response) {
            const details = ex.response.data && ex.response.data.errors ? ex.response.data.errors.map((e) => e.message).join(" | ") : ex.message;
            throw new Error(`${ex.response.status} - ${details}`);
        }
        else {
            throw ex;
        }
    }
};
